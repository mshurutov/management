[TOC]

Стандарты, правила, регламенты процесса разработки.
===================================================

Код.
----

IDE.
----

Правила работы с БД.
--------------------

**ВАЖНО!** При разработке продуктов с использованием СУБД PostgresQL необходимо в обязательном порядке учитывать рекомендации из Wiki: [Не надо делать так!](https://wiki.postgresql.org/wiki/Don%27t_Do_This).<BR>
Как пример - [разбор использования `varchar(n) vs text`](https://ru-postgres.livejournal.com/65930.html).

### PostgresQL.

#### Подключение к СУБД.

Эксплуатация подразумевает мониторинг всех сущностей (ПО) систем, соответственно, одним из важнейших способов снижения стоимости использования таких систем является снижение количества этих сущностей. Применительно к СУБД PostgresQL подобное сокращение может быть выполнено перенесением функций балансировки со специально выделенного балансировщика на сторону прикладного ПО, а именно - указанием всех хостов отказоустойчивого кластера в строке подключения с выставлением признака, что подключаться надо к мастеру ([Документация по строке подключения](https://postgrespro.ru/docs/postgresql/11/libpq-connect#LIBPQ-CONNSTRING)).
В виде URI:
```
conn_string='postgresql://host1:port1,host2:port2,host3:port3/dbname?target_session_attrs=read-write'
```
В виде строки параметров:
```
conn_string='host=host1,host2,host3 port=port1,port2,port3 ... target_session_attrs=read-write'
```
Во втором случае количество портов должно соответствовать количеству хостов, и эти порты должны быть указаны в том же порядке, что и хосты (см. вышеприведённую ссылку на документацию).

#### Порядок именования объектов.

Наименования объектов БД в СУБД PostgresQL должны удовлетворять следующему регулярному выражению: "`[a-z][a-z_0-9]*`". Все остальные символы, например, верхний регистр (`[A-Z]`), дефис ("`-`"), точка ("`.`") - недопустимы.

#### Предотвращение распухания таблиц и индексов.

Одной из особенностей транзакционного механизма СУБД PostgresQL является тот факт, что любой запрос к БД является транзакцией. Если запрос на выборку данных, то транзакция виртуальная (не меняется счётчик транзакций), если на изменение данных (`CREATE`/`ALTER`/`DROP` для объектов СУБД, `INSERT`/`UPDATE`/`DELETE` для данных), то транзакция явная (счётчик тразакций изменяется).
Особенности реализации механизма MVCC в СУБД PostgresQL таковы, что долго играющие транзакции, особенно при активном изменении данных (под изменением понимается вставка `INSERT`, собственно изменение - `UPDATE`, удаление - `DELETE`), вызывают зачастую фатальное распухание таблиц и индексов (в моей практике встречались ситуации, когда на 9 живых записей в таблице набирались миллионы мертвых версий). Эти особенности налагают следующие ограничения на работу прикладного ПО с БД под управлением `postgres`-а:

1. для массовой вставки необходимо использовать команду COPY (наглядным примером использования этой команды может служить вывод утилиты `pg_dump`);
2. массового обновления данных (`UPDATE` большого количества записей таблицы) необходимо избегать;
3. обращения к внешним ресурсам из СУБД недопустимы, равно как и такие же обращения при явном объявлении транзакций, т.е. в прикладном коде явно вызывается начало транзакции `BEGIN`, выполняются какие-то запросы, затем происходит обращение к внешним ресурсам с результатами запросов, и только потом фиксирование (`COMMIT`) или откат (`ROLLBACK`) транзакции.

#### Производительность.

В `SQL` оператор `OR` в выражении `WHERE` работает несколько иначе, нежели в обычных императивных языках программирования, а именно - вычисляются все выражения и в выборку попадают такие записи, для которых значение выражения будет `TRUE`:

```
msql=> select * from salespeople ;
 snum |  sname  |   city    | comm 
------+---------+-----------+------
 1001 | Peel    | London    | 0.12
 1002 | Serres  | San Jose  | 0.13
 1004 | Motika  | London    | 0.11
 1007 | Rifkin  | Barcelona | 0.15
 1003 | Axelrod | New York  | 0.10
(5 rows)

msql=> select * from salespeople where city = 'London' or city = 'San Jose';
 snum | sname  |   city   | comm 
------+--------+----------+------
 1001 | Peel   | London   | 0.12
 1002 | Serres | San Jose | 0.13
 1004 | Motika | London   | 0.11
(3 rows)

msql=>
```

В общем случае использование `OR` приводит к полному сканированию таблиц(ы). И уж совсем непонятно, что решит планировщик при использовании в параметризованных запросах следующей конструкции:

```
SELECT ...
WHERE ...
    ($1 IS NULL OR $2 = any_field)
    ...
```

А потому подобных конструкций необходимо избегать. Проверяйте параметр на NULL в прикладном коде, пожалуйста.
