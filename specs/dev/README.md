[TOC]

Стандарты, правила, регламенты процесса разработки.
===================================================

Код.
----

IDE.
----

Правила работы с БД.
--------------------

### PostgresQL.

#### Порядок именования объектов.

Наименования объектов БД в СУБД PostgresQL должны удовлетворять следующему регулярному выражению: "`[a-z][a-z_0-9]*`". Все остальные символы, например, верхний регистр (`[A-Z]`), дефис ("`-`"), точка ("`.`") - недопустимы.

#### Предотвращение распухания таблиц и индексов.

Одной из особенностей транзакционного механизма СУБД PostgresQL является тот факт, что любой запрос к БД является транзакцией. Если запрос на выборку данных, то транзакция виртуальная (не меняется счётчик транзакций), если на изменение данных (`CREATE`/`ALTER`/`DROP` для объектов СУБД, `INSERT`/`UPDATE`/`DELETE` для данных), то транзакция явная (счётчик тразакций изменяется).
Особенности реализации механизма MVCC в СУБД PostgresQL таковы, что долго играющие транзакции, особенно при активном изменении данных (под изменением понимается вставка `INSERT`, собственно изменение - `UPDATE`, удаление - `DELETE`), вызывают зачастую фатальное распухание таблиц и индексов (в моей практике встречались ситуации, когда на 9 живых записей в таблице набирались миллионы мертвых версий). Эти особенности налагают следующие ограничения на работу прикладного ПО с БД под управлением `postgres`-а:

1. для массовой вставки необходимо использовать команду COPY (наглядным примером использования этой команды может служить вывод утилиты `pg_dump`);
2. массового обновления данных (`UPDATE` большого количества записей таблицы) необходимо избегать;
3. обращения к внешним ресурсам из СУБД недопустимы, равно как и такие же обращения при явном объявлении транзакций, т.е. в прикладном коде явно вызывается начало транзакции `BEGIN`, выполняются какие-то запросы, затем происходит обращение к внешним ресурсам с результатами запросов, и только потом фиксирование (`COMMIT`) или откат (`ROLLBACK`) транзакции.

#### Производительность.

В `SQL` оператор `OR` в выражении `WHERE` работает несколько иначе, нежели в обычных императивных языках программирования, а именно - вычисляются все выражения и в выборку попадают такие записи, для которых значение выражения будет `TRUE`:

```
msql=> select * from salespeople ;
 snum |  sname  |   city    | comm 
------+---------+-----------+------
 1001 | Peel    | London    | 0.12
 1002 | Serres  | San Jose  | 0.13
 1004 | Motika  | London    | 0.11
 1007 | Rifkin  | Barcelona | 0.15
 1003 | Axelrod | New York  | 0.10
(5 rows)

msql=> select * from salespeople where city = 'London' or city = 'San Jose';
 snum | sname  |   city   | comm 
------+--------+----------+------
 1001 | Peel   | London   | 0.12
 1002 | Serres | San Jose | 0.13
 1004 | Motika | London   | 0.11
(3 rows)

msql=>
```

В общем случае использование `OR` приводит к полному сканированию таблицы. И уж совсем непонятно, что решит планировщик при использовании в параметризованных запросах следующей конструкции:

```
SELECT ...
WHERE ...
    ($1 IS NULL OR $2 = any_field)
    ...
```

А потому подобных конструкций необходимо избегать. Проверяйте параметр на NULL в прикладном коде, пожалуйста.
