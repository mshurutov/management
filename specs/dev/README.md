[TOC]

Стандарты, правила, регламенты процесса разработки.
===================================================

Код.
----

IDE.
----

Требования при работе с СУБД.
--------------------

### Архитектура.

При работе с СУБД/БД необходимо понимать разницу между двумя этими сущностями (вольный перевод точной математики на русский разговорный):
* СУБД - обеспечивает согласованное допустимое состояние данных, гарантирует, что вы прочитаете из БД то, что вы туда положили, когда БД управляется СУБД;
* БД - обеспечивает только размещение на диске (без каких-либо гарантий!) и обработку (вставка, изменение, удаление, выборка) данных. В общем случае БД не гарантирует, что вы прочитаете именно то, что положили в эту БД.

<A HREF="maindbms">**Главное правило использования СУБД:** Если СУБД что-то может и умеет, то она обязана это делать!</A><BR>
Наиболее частое нарушение этого требования - в следующем пункте.

#### Уровни изоляции.

Лучшее описание уровней изоляции - в [документации по постгресу](https://www.postgresql.org/docs/current/transaction-iso.html) и [переводе этой документации на русский язык](https://postgrespro.ru/docs/postgresql/17/transaction-iso).<BR>
Так вот. Выбирать режим изоляции по-умолчанию (`READ COMMITTED`), а потом в прикладном коде пытаться реализовать более высокий (`REPEATABLE READ`, например) - **НЕДОПУСТИМО!**<BR>
Помимо общих требований к уровням изоляции следует помнить, что, выставляя общий уровень изоляции `SERIALIZABLE`, понижать уровень изоляции нельзя ни в коем случае. Отрывок из [документации](https://postgrespro.ru/docs/postgresql/17/transaction-iso#XACT-SERIALIZABLE):
```
Если бы одна из этих транзакций работала в режиме Repeatable Read, зафиксироваться могли бы обе;
```

#### Микросервисы.

При следовании модным тенденциям разбиения на микросервисы, вы ОБЯЗАНЫ понимать, что с буковкой "C" (Consistency - Согласованность) в аббревиатуре `ACID` придётся распрощаться. (см. [Главное правило использования СУБД](#maindbms)). Т.е. там, где требуется связь между данными, эти данные должны жить в одной БД.

#### Large objects

[ОЧЕНЬ БОЛЬШИЕ ОБЪЕКТЫ](https://postgrespro.ru/docs/postgresql/17/largeobjects) хранятся в системной таблице:
```
Все большие объекты хранятся в одной системной таблице с именем pg_largeobject. Для каждого большого объекта также имеется запись в системной таблице pg_largeobject_metadata.
```
Соответственно, при обновлении старшей версии СУБД эти объекты попадут в дамп, который делается перед копированием/переносом собственно данных.<BR>
Известны случаи, когда БД размером 100ГБ обновлялась более 10 часов из-за наличия вот таких объектов. Соответственно, их использование недопустимо.

#### Эксплуатация. Мониторинг.

Помимо согласованности данных при разнесении БД по различным экземплярам есть ещё цена мониторинга, а именно - каждый хост (**ХОСТ!**), каковых в проде - два штуки на экземпляр в очень плохом случае плюс три для DCS, должен [мониториться](../ops/swspecs/README.md#каждый-хост). Т.е. разнося, например, 5 БД с одного экземпляра (5 хостов), вы получаете не 5 а 25 хостов в мониторинге. Это - дисковые ресурсы для хранения значений параметров мониторинга. Это ЦПУ и память на обработку. А когда вы выносите данные из схем одной БД, то у вас появляеется разбиение не только по хостам, но и по БД, что также требует уже более значительных дисковых ресурсов и, соответственно, ЦПУ и памяти на обработку данных мониторинга СУБД.

### PostgresQL.

**ВАЖНО!** При разработке продуктов с использованием СУБД PostgresQL необходимо в обязательном порядке учитывать рекомендации из Wiki: [Не надо делать так!](https://wiki.postgresql.org/wiki/Don%27t_Do_This).<BR>
Как пример - [разбор использования `varchar(n) vs text`](https://ru-postgres.livejournal.com/65930.html).

#### Подключение к СУБД.

Как говорилось выше, эксплуатация подразумевает мониторинг всех сущностей (ПО) систем, соответственно, одним из важнейших способов снижения стоимости использования таких систем является снижение количества этих сущностей. Применительно к СУБД PostgresQL подобное сокращение может быть выполнено перенесением функций балансировки со специально выделенного балансировщика на сторону прикладного ПО, а именно - указанием всех хостов отказоустойчивого кластера в строке подключения с выставлением признака, что подключаться надо к мастеру ([Документация по строке подключения](https://postgrespro.ru/docs/postgresql/17/libpq-connect#LIBPQ-CONNSTRING), [параметр `target_session_attrs`](https://postgrespro.ru/docs/postgresql/17/libpq-connect#LIBPQ-CONNECT-TARGET-SESSION-ATTRS)).
В виде URI:
```
conn_string='postgresql://host1:port1,host2:port2,host3:port3/dbname?target_session_attrs=read-write'
```
В виде строки параметров:
```
conn_string='host=host1,host2,host3 port=port1,port2,port3 ... target_session_attrs=read-write'
```
Во втором случае количество портов должно соответствовать количеству хостов, и эти порты должны быть указаны в том же порядке, что и хосты (см. вышеприведённую ссылку на документацию).

#### Порядок именования объектов.

Наименования объектов БД в СУБД PostgresQL должны удовлетворять следующему регулярному выражению: "`[a-z][a-z_0-9]*`". Все остальные символы, например, верхний регистр (`[A-Z]`), дефис ("`-`"), точка ("`.`") - недопустимы.

#### Предотвращение распухания таблиц и индексов.

Одной из особенностей транзакционного механизма СУБД PostgresQL является тот факт, что любой запрос к БД является транзакцией. Если запрос на выборку данных, то транзакция виртуальная (не меняется счётчик транзакций), если на изменение данных (`CREATE`/`ALTER`/`DROP` для объектов СУБД, `INSERT`/`UPDATE`/`DELETE` для данных), то транзакция явная (счётчик тразакций изменяется).<BR>
Особенности реализации механизма MVCC в СУБД PostgresQL таковы, что долго играющие транзакции, особенно при активном изменении данных (под изменением понимается вставка `INSERT`, собственно изменение - `UPDATE`, удаление - `DELETE`), вызывают зачастую фатальное распухание таблиц и индексов (в моей практике встречались ситуации, когда на 9 живых записей в таблице набирались миллионы мертвых версий). Эти особенности налагают следующие ограничения на работу прикладного ПО с БД под управлением `postgres`-а:

1. для массовой вставки необходимо использовать команду COPY (наглядным примером использования этой команды может служить вывод утилиты `pg_dump`);
2. массового обновления данных (`UPDATE` большого количества записей таблицы) необходимо избегать;
3. обращения к внешним ресурсам из СУБД недопустимы, равно как и такие же обращения при явном объявлении транзакций, т.е. в прикладном коде явно вызывается начало транзакции `BEGIN`, выполняются какие-то запросы, затем происходит обращение к внешним ресурсам с результатами запросов, и только потом фиксирование (`COMMIT`) или откат (`ROLLBACK`) транзакции.

#### Производительность.

В `SQL` оператор `OR` в выражении `WHERE` работает несколько иначе, нежели в обычных императивных языках программирования, а именно - вычисляются все выражения и в выборку попадают такие записи, для которых значение выражения будет `TRUE`:

```
msql=> select * from salespeople ;
 snum |  sname  |   city    | comm 
------+---------+-----------+------
 1001 | Peel    | London    | 0.12
 1002 | Serres  | San Jose  | 0.13
 1004 | Motika  | London    | 0.11
 1007 | Rifkin  | Barcelona | 0.15
 1003 | Axelrod | New York  | 0.10
(5 rows)

msql=> select * from salespeople where city = 'London' or city = 'San Jose';
 snum | sname  |   city   | comm 
------+--------+----------+------
 1001 | Peel   | London   | 0.12
 1002 | Serres | San Jose | 0.13
 1004 | Motika | London   | 0.11
(3 rows)

msql=>
```

В общем случае использование `OR` приводит к полному сканированию таблиц(ы). И уж совсем непонятно, что решит планировщик при использовании в параметризованных запросах следующей конструкции:

```
SELECT ...
WHERE ...
    ($1 IS NULL OR $2 = any_field)
    ...
```

А потому подобных конструкций необходимо избегать. Проверяйте параметр на NULL в прикладном коде, пожалуйста.
